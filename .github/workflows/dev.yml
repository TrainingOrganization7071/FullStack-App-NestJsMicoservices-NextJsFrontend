name: CI/CD Microservices Pipeline

# Define events that trigger this workflow:
# - A push to the "dev" branch, targeting changes in the "services" folder.
# - Pull requests to the "dev" branch.
# - Manual workflow_dispatch trigger.
on:
  push:
    paths:
      - "services/**"
    branches:
      - dev
  pull_request:
    branches:
      - dev
  workflow_dispatch:

# Set environment variables used across multiple jobs
env:
  RESOURCE_GROUP: "minimal_infra_auth"
  NODE_VENSION: "20.x"

jobs:

  # Job to detect changed microservices in the "services" directory
  discover_services_by_path:
    name: Find out all the microservices from path directory
    runs-on: ubuntu-latest
    outputs:
      environments: ${{ steps.list-environments.outputs.environments }}

    steps:
      # Step 1: Checkout the repository with a shallow clone for faster performance
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Step 2: Identify directories in "services" with changes in the latest commit
      - name: Output all the environments in the infrastructure folder
        id: list-environments
        working-directory: services
        run: |
          directories=($(ls -d */))
          directories=("${directories[@]%/}")
          json_array=()
          for dir in "${directories[@]}"; do
            if git diff --name-only HEAD^ HEAD | grep -q "^services/$dir/" && [[ ! " ${excluded_directories[@]} " =~ " $dir " ]]; then
              json_array+=("\"$dir\"")
            fi
          done
          json_output="[$(IFS=,; echo "${json_array[*]}")]"
          echo "--> $json_output"
          echo "environments=$json_output" >> $GITHUB_OUTPUT

      # Step 3: Display detected changed microservices for debugging and verification
      - name: Debug Changed Microservices output
        run: |
          echo "Changed Microservices: ${{ steps.list-environments.outputs.environments }}"


  # Lint Job to enforce code quality standards
  lint:
    name: Lint Microservices
    runs-on: ubuntu-latest
    needs: [discover_services_by_path]
    if: ${{ needs.discover_services_by_path.outputs.environments != '[]' }}
    strategy:
      matrix:
        environments: ${{ fromJson(needs.discover_services_by_path.outputs.environments) }}
    outputs:
      environments: ${{ needs.discover_services_by_path.outputs.environments }}

    steps:
      # Run Echo command
      - name: Debug Environment
        run: |
          echo "Changed Microservices: ${{ fromJson(needs.discover_services_by_path.outputs.environments) }}"

      # Step 1: Checkout the repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Step 2: Set up Node.js environment with specified version
      - name: Set Up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      # Step 3: Cache Node.js dependencies to improve pipeline speed
      - name: Cache Node.js Modules
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      # Step 4: Install necessary dependencies in the microservice directory
      - name: Install Dependencies
        run: |
          cd ./services/${{ matrix.environments }}
          npm ci

      # Step 5: Run linting to enforce code quality and consistency
      - name: Run Lint
        run: |
          cd ./services/${{ matrix.environments }}
          npm run lint --if-present


  # Build Job to compile the microservices
  build:
    name: Build Microservices
    runs-on: ubuntu-latest
    needs: [lint]
    strategy:
      matrix:
        environments: ${{ fromJson(needs.lint.outputs.environments || '[]') }}
    outputs:
      environments: ${{ needs.lint.outputs.environments }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Set Up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Cache Node.js Modules
        uses: actions/cache@v3
        with:
          path: ~/.npm
          key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install Dependencies
        run: |
          cd ./services/${{ matrix.environments }}
          npm ci

      - name: Run Build
        run: |
          cd ./services/${{ matrix.environments }}
          npm run build --if-present

      - name: Upload Build Artifact
        uses: actions/upload-artifact@v3
        with:
          name: ${{ matrix.environments }}-build
          path: ./services/${{ matrix.environments }}/dist


  # Docker Build and Push Job to containerize and deploy microservices
  docker_build_push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [build]
    strategy:
      matrix:
        environments: ${{ fromJson(needs.build.outputs.environments || '[]') }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Build and Push Docker Image
        run: |
          docker build -t ${{ secrets.DOCKER_USERNAME }}/${{ matrix.environments }}:latest ./services/${{ matrix.environments }}
          docker push ${{ secrets.DOCKER_USERNAME }}/${{ matrix.environments }}:latest


#  #Deploy All Microservice docker images to ACR
#  deploy_To_ACR:
#    name: 'Build and Push to ACR'
#    runs-on: ubuntu-latest
#    needs: [build]
#    strategy:
#      matrix:
#        environments: ${{ fromJson(needs.build.outputs.environments || '[]') }}
#    outputs:
#      environments: ${{ needs.build.outputs.environments }}
#    env:
#      ACR_NAME: "containerRegistry1alnqmasz"
#
#    defaults:
#      run:
#        shell: bash
#
#    steps:
#      - name: Checkout repository
#        uses: actions/checkout@v4
#        with:
#          fetch-depth: 0  # Fetch full commit history, not a shallow clone
#
#      - name: Azure ACR [Docker Rejistry] Login
#        uses: azure/docker-login@v1
#        with:
#          login-server: ${{ env.ACR_NAME }}.azurecr.io
#          username: ${{ secrets.ACR_USERNAME }}
#          password: ${{ secrets.ACR_PASSWORD }}
#
#      # Display the content of the Dockerfile
#      - name: Display Dockerfile content
#        run: |
#           cat ./services/${{ matrix.environments }}/Dockerfile
#           
#      # Build the Docker Image
#      - name: Build Docker Image
#        run: |
#          docker build -t ${{ matrix.environments }}:latest ./services/${{ matrix.environments }}
#
#      - name: Tag Docker Image for ACR
#        run: |
#          docker tag ${{ matrix.environments }}:latest  ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.environments }}:latest
#
#      - name: Push Docker Image to ACR
#        run: |
#          docker push ${{ env.ACR_NAME }}.azurecr.io/${{ matrix.environments }}:latest


#az aks update -n <aks-cluster-name> -g <resource-group-name> --attach-acr <acr-name>
#  # Deploy to Azure Kubernetes Cluster
#  Deploy_To_AKS:
#    runs-on: ubuntu-latest
#    needs: [ deploy_To_ACR ]
#    strategy:
#      matrix:
#        environments: ${{ fromJson(needs.deploy_To_ACR.outputs.environments || '[]') }}
#
#    steps:
#      - name: Checkout repository
#        uses: actions/checkout@v4
#        with:
#          fetch-depth: 0  # Fetch full commit history, not a shallow clone
#
#      - name: Install Azure CLI
#        run: |
#          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash
#
#      # Use kubelogin to configure your kubeconfig for Azure auth
#      - name: Set up kubelogin for non-interactive login
#        uses: azure/use-kubelogin@v1
#        with:
#          kubelogin-version: 'v0.0.25'
#        
#      # Login to Azure using the service principal credentials
#      - name: Azure Login -> Creds
#        uses: azure/login@v2
#        with:
#          creds: '{"clientId":"${{ secrets.AZURE_CLIENT_ID }}","clientSecret":"${{ secrets.AZURE_CLIENT_SECRET }}","subscriptionId":"${{ secrets.AZURE_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.AZURE_TENANT_ID }}"}'
#
#
#      # Retrieves your Azure Kubernetes Service cluster's kubeconfig file
#      - name: Get K8s context
#        uses: azure/aks-set-context@v3
#        with:
#          resource-group: ${{ env.RESOURCE_GROUP }}
#          cluster-name: ${{ env.CLUSTER_NAME }}
#          admin: 'false'
#          use-kubelogin: 'true'
#        
#      # Install kubectl manually
#      - name: Install kubectl
#        run: |
#          sudo az aks install-cli
#
#      # Get Nodes - test
#      - name: Get Nodes
#        run: |
#          kubectl get nodes
#        
#      # ECHO - test
#      - name: ECHO
#        run: |
#          echo  "--------------------------------"
#          echo  "--------------------------------"
#
#      # Replace the placeholders in the Kubernetes manifest with the actual ACR URL, image name, and tag
#      - name: Replace image placeholders in deployment.yml
#        run: |
#          sed -i 's|ACR_URL_PLACEHOLDER|${{ env.ACR_NAME }}.azurecr.io|g' ./${{ matrix.environments }}/k8s/deployment.yml
#          sed -i 's|IMAGE_NAME_PLACEHOLDER|${{ matrix.docker_image_name }}-microservice|g' ./${{ matrix.environments }}/k8s/deployment.yml
#          sed -i 's|IMAGE_TAG_PLACEHOLDER|${{ env.DOCKER_IMAGE_TAG }}|g' ./${{ matrix.environments }}/k8s/deployment.yml
#          sed -i "s|REDEPLOY_TIMESTAMP_PLACEHOLDER|$(date +%s)|g" ./${{ matrix.environments }}/k8s/deployment.yml
#
#      # ECHO Deployment.yml - Display Content of Manifest
#      - name: Echo Deployment Manifest
#        run: |
#          echo "Displaying the content of the deployment manifest for ${{ matrix.environments }}:"
#          cat ./${{ matrix.environments }}/k8s/deployment.yml
#
#      # Deploys application based on given manifest file
#      - name: Deploys application
#        uses: Azure/k8s-deploy@v4
#        with:
#          action: deploy
#          manifests: ./${{ matrix.environments }}/k8s/deployment.yml
#          force: true  # Force redeployment even if deployment already exists
#
#      # Fetch detailed deployment logs
#      - name: Get Deployment Logs
#        run: |
#          kubectl describe deployment ${{ matrix.docker_image_name }}-deployment --v=6
#          kubectl logs deployment/${{ matrix.docker_image_name }}-deployment --v=6







